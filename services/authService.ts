
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { SaveData, UserProfile, Mail, BattleState, GAME_SERVERS, Character, BattleLogEntry } from '../types';

export interface WorldChatMessage {
  id: number;
  server_id: string;
  username: string;
  content: string;
  is_admin: boolean;
  timestamp: number;
}

const SUPABASE_URL = "https://nrcubosxzyyjzjhfcvwq.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5yY3Vib3N4enl5anpqaGZjdndxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAyMTA3OTAsImV4cCI6MjA4NTc4Njc5MH0.sz43w_xWD2bHKyaWJLATpNZK5SIc_jvTYUghSX_hw8w"; 

// UPDATED SQL: Added indexes and consolidated structure
const DB_SETUP_SQL = `
-- 1. Bảng lưu trữ người chơi (Players)
create table if not exists tensura_players (
  username text primary key,
  password text not null,
  server_id text not null default 'sv_global',
  is_admin boolean default false,
  is_banned boolean default false,
  last_active bigint,
  
  -- Dữ liệu JSON chính (Lưu trữ toàn bộ cấu trúc nhân vật phức tạp)
  save_data jsonb,
  
  -- Các cột tách lẻ để Query/Filter nhanh (Leaderboard)
  level int default 1,
  evolution_stage text,
  strength bigint default 10,
  magic bigint default 10,
  agility bigint default 10,
  defense bigint default 10,
  skills text[] default '{}',
  inventory text[] default '{}',
  
  mailbox jsonb default '[]',
  created_at timestamptz default now()
);

-- Tạo Index để tìm kiếm nhanh
create index if not exists idx_players_server on tensura_players(server_id);
create index if not exists idx_players_active on tensura_players(last_active);

-- 2. Bảng chat thế giới (World Chat)
create table if not exists tensura_world_chat (
  id bigint generated by default as identity primary key,
  server_id text not null,
  username text not null,
  content text not null,
  is_admin boolean default false,
  timestamp bigint not null,
  created_at timestamptz default now()
);

-- Index cho chat log
create index if not exists idx_chat_timestamp on tensura_world_chat(timestamp);

-- 3. Bảng đấu trường PvP (Battles)
create table if not exists tensura_battles (
  id bigint generated by default as identity primary key,
  server_id text not null,
  challenger text not null,
  target text not null,
  status text not null, -- PENDING, IN_PROGRESS, FINISHED, DECLINED
  winner text,
  turn text,
  logs jsonb default '[]',
  p1_hp bigint, p1_max_hp bigint,
  p2_hp bigint, p2_max_hp bigint,
  created_at timestamptz default now()
);

-- Index cho PvP
create index if not exists idx_battles_status on tensura_battles(status);
create index if not exists idx_battles_participants on tensura_battles(challenger, target);

-- 4. Kích hoạt Realtime (Supabase Specific)
alter publication supabase_realtime add table tensura_world_chat;
alter publication supabase_realtime add table tensura_battles;
alter publication supabase_realtime add table tensura_players; 
`;

class AuthService {
    private supabase: SupabaseClient;
    private serverId = 'sv_global'; // Default global server
    private chatSubscription: any = null;
    private battleSubscription: any = null;
    public ADMIN_ID = 'pojani0b';

    constructor() {
        // Always enforce global server
        this.serverId = 'sv_global';
        this.supabase = createClient(SUPABASE_URL, SUPABASE_KEY);
    }

    setServer(id: string) {
        this.serverId = 'sv_global'; // Override to ensure single server
    }

    getServerId() { return this.serverId; }
    
    getServerName() {
        return "Global Tempest";
    }

    async checkConnection() {
        try {
            const { error } = await this.supabase.from('tensura_players').select('count', { count: 'exact', head: true });
            if (error) throw error;
            return { online: true, message: 'Kết nối Tiếng Nói Thế Giới ổn định.' };
        } catch (e: any) {
            return { online: false, message: 'Lỗi kết nối: ' + e.message };
        }
    }

    async register(username: string, password: string) {
        // Admin Chính
        if (username === this.ADMIN_ID && password !== 'admin2025') {
            return { success: false, error: 'Mật khẩu Admin không chính xác.' };
        }
        // Admin Phụ (Requested)
        if (username === '2' && password !== '2') {
            return { success: false, error: 'Mật khẩu quản trị viên (2) không chính xác.' };
        }

        const { data: existing } = await this.supabase
            .from('tensura_players')
            .select('username')
            .eq('username', username)
            .single();

        if (existing) return { success: false, error: 'Định danh linh hồn đã tồn tại.' };

        const isAdmin = (username === this.ADMIN_ID || username === '2');

        const newUser = {
            username,
            password,
            server_id: this.serverId,
            is_admin: isAdmin,
            last_active: Date.now(),
            save_data: null,
            mailbox: []
        };

        const { error } = await this.supabase.from('tensura_players').insert(newUser);
        if (error) return { success: false, error: error.message };
        return { success: true };
    }

    async login(username: string, password: string) {
        const { data, error } = await this.supabase
            .from('tensura_players')
            .select('*')
            .eq('username', username)
            .eq('password', password)
            .single();

        if (error || !data) return { user: null, error: 'Sai tên đăng nhập hoặc mật khẩu.' };
        if (data.is_banned) return { user: null, error: 'Linh hồn này đã bị phong ấn (Banned).' };

        const userProfile: UserProfile = {
            username: data.username,
            createdAt: new Date(data.created_at).getTime(),
            isAdmin: data.is_admin,
            isBanned: data.is_banned,
            lastActive: data.last_active
        };

        localStorage.setItem('tensura_session', JSON.stringify(userProfile));
        return { user: userProfile };
    }

    logout() {
        localStorage.removeItem('tensura_session');
        if (this.chatSubscription) this.chatSubscription.unsubscribe();
        if (this.battleSubscription) this.battleSubscription.unsubscribe();
    }

    getCurrentUserLocal(): UserProfile | null {
        try {
            return JSON.parse(localStorage.getItem('tensura_session') || 'null');
        } catch (e) { return null; }
    }

    async getCurrentUser() { return this.getCurrentUserLocal(); }

    async getAllUsers() {
        const { data } = await this.supabase
            .from('tensura_players')
            .select('*')
            .order('last_active', { ascending: false });
        return data?.map(u => ({
            username: u.username,
            createdAt: new Date(u.created_at).getTime(),
            isAdmin: u.is_admin,
            isBanned: u.is_banned,
            lastActive: u.last_active,
            saveData: u.save_data
        })) || [];
    }

    async saveGameData(username: string, data: SaveData) {
        // Update both JSON and individual columns for SQL querying
        const stats = data.character.status;
        const attr = data.character.attributes;
        
        const updatePayload = {
            save_data: data,
            last_active: Date.now(),
            level: stats.level,
            evolution_stage: stats.evolutionStage,
            strength: attr.strength,
            magic: attr.magic,
            agility: attr.agility,
            defense: attr.defense,
            skills: stats.skills,
            inventory: stats.inventory
        };

        const { error } = await this.supabase.from('tensura_players').update(updatePayload).eq('username', username);
        if (error) return { success: false, error: error.message };
        return { success: true };
    }

    async loadGameData(username: string): Promise<SaveData | null> {
        const { data } = await this.supabase.from('tensura_players').select('save_data').eq('username', username).single();
        return data?.save_data || null;
    }

    async deleteAccount(username: string) {
        await this.supabase.from('tensura_players').delete().eq('username', username);
    }

    async deleteGameData(username: string) {
        await this.supabase.from('tensura_players').update({ save_data: null }).eq('username', username);
    }

    async banUser(username: string) {
        await this.supabase.from('tensura_players').update({ is_banned: true }).eq('username', username);
    }

    async unbanUser(username: string) {
        await this.supabase.from('tensura_players').update({ is_banned: false }).eq('username', username);
    }

    async unbanAllUsers() {
        await this.supabase.from('tensura_players').update({ is_banned: false }).eq('is_banned', true);
    }

    async adminDeleteUser(username: string) {
        await this.deleteAccount(username);
    }

    async adminUpdateBattleStats(battleId: number, p1_hp: number, p2_hp: number) {
        await this.supabase.from('tensura_battles').update({ 
            p1_hp: p1_hp,
            p2_hp: p2_hp
        }).eq('id', battleId);
    }

    getDatabaseSetupSQL() {
        return DB_SETUP_SQL;
    }

    async getMailbox(username: string): Promise<Mail[]> {
        const { data } = await this.supabase.from('tensura_players').select('mailbox').eq('username', username).single();
        return data?.mailbox || [];
    }

    async sendMail(to: string, mail: Partial<Mail>) {
        const box = await this.getMailbox(to);
        const newMail: Mail = {
            id: Date.now().toString(),
            sender: mail.sender || 'Hệ thống',
            title: mail.title || 'Thông báo',
            content: mail.content || '',
            type: mail.type || 'TEXT',
            attachment: mail.attachment,
            timestamp: Date.now(),
            isRead: false,
            isClaimed: false
        };
        box.unshift(newMail);
        await this.supabase.from('tensura_players').update({ mailbox: box }).eq('username', to);
    }

    async markMailRead(username: string, mailId: string) {
        const box = await this.getMailbox(username);
        const updatedBox = box.map(m => m.id === mailId ? { ...m, isRead: true } : m);
        await this.supabase.from('tensura_players').update({ mailbox: updatedBox }).eq('username', username);
    }

    async claimMailReward(username: string, mailId: string) {
        const box = await this.getMailbox(username);
        let claimed = false;
        const updatedBox = box.map(m => {
            if (m.id === mailId && !m.isClaimed) {
                claimed = true;
                return { ...m, isClaimed: true };
            }
            return m;
        });
        if (claimed) {
            await this.supabase.from('tensura_players').update({ mailbox: updatedBox }).eq('username', username);
            return true;
        }
        return false;
    }

    async getWorldChatHistory(limit: number): Promise<WorldChatMessage[]> {
        const { data } = await this.supabase.from('tensura_world_chat').select('*').order('timestamp', { ascending: true }).limit(limit);
        return data || [];
    }

    async sendWorldChatMessage(username: string, content: string, isAdmin: boolean) {
        const newMsg = { server_id: this.serverId, username, content, is_admin: isAdmin, timestamp: Date.now() };
        const { error } = await this.supabase.from('tensura_world_chat').insert(newMsg);
        return !error;
    }

    subscribeToWorldChat(onMsg: (p: any) => void, onStatus: (s: string) => void) {
        const channel = this.supabase.channel(`world_chat_global`)
            .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'tensura_world_chat' }, (payload) => onMsg(payload))
            .subscribe((status) => onStatus(status));
        return () => this.supabase.removeChannel(channel);
    }

    async createBattle(challenger: string, target: string, p1hp: number, p1max: number, p2hp: number, p2max: number): Promise<boolean | string> {
        try {
            await this.supabase.from('tensura_battles').delete().or(`challenger.eq.${challenger},target.eq.${challenger}`);
            const newBattle = {
                server_id: this.serverId,
                challenger,
                target,
                status: 'PENDING',
                turn: challenger,
                logs: [],
                p1_hp: p1hp, p1_max_hp: p1max,
                p2_hp: p2hp, p2_max_hp: p2max
            };
            const { error } = await this.supabase.from('tensura_battles').insert(newBattle);
            if (error) {
                if (error.code === '42P01') return 'MISSING_TABLE';
                return false;
            }
            return true;
        } catch (e) {
            return false;
        }
    }

    subscribeToBattles(username: string, cb: (payload: any) => void) {
        const channel = this.supabase.channel(`battles_global`)
            .on('postgres_changes', { event: '*', schema: 'public', table: 'tensura_battles' }, (payload) => cb(payload))
            .subscribe();
        return () => this.supabase.removeChannel(channel);
    }

    // --- OVERHAULED COMBAT MECHANISM ---
    async performBattleAction(battle: BattleState, user: UserProfile, skillName: string, attackerStats: Character) {
        const isChallenger = user.username === battle.challenger;
        const opponentName = isChallenger ? battle.target : battle.challenger;
        
        // 1. Calculate Base Damage (Uncapped)
        // Dmg = (Str * 2 + Mag * 3) * Level Multiplier
        let baseDamage = (attackerStats.attributes.strength * 2 + attackerStats.attributes.magic * 3);
        baseDamage = baseDamage * (1 + attackerStats.status.level * 0.1); 
        
        // Random variance +/- 10%
        baseDamage = baseDamage * (0.9 + Math.random() * 0.2);

        let finalDamage = baseDamage;
        let description = "";
        let effectType: BattleLogEntry['effect'] = 'NORMAL';

        // 2. Skill Effects Analysis
        const sLower = skillName.toLowerCase();

        if (sLower === "đánh thường") {
            finalDamage *= 0.5; // Basic attack is weaker
            description = `Tung đòn đánh cơ bản.`;
        }
        else if (sLower.includes("hỏa") || sLower.includes("lửa") || sLower.includes("fire") || sLower.includes("flare")) {
            finalDamage *= 1.5;
            description = `Ngọn lửa thiêu đốt! Gây sát thương chí mạng do nhiệt.`;
            effectType = 'CRIT';
        } 
        else if (sLower.includes("băng") || sLower.includes("tuyết") || sLower.includes("ice") || sLower.includes("blizzard")) {
            // Ice doesn't boost dmg much but conceptually slows (visual only for now)
            description = `Đóng băng không gian. Đối thủ bị tê liệt nhẹ.`;
            effectType = 'STUN';
        }
        else if (sLower.includes("lôi") || sLower.includes("sét") || sLower.includes("lightning") || sLower.includes("thunder")) {
            finalDamage *= 1.3;
            description = `Tia sét xuyên phá phòng thủ!`;
            effectType = 'DOUBLE';
        }
        else if (sLower.includes("bạo thực") || sLower.includes("beelzebuth") || sLower.includes("gluttony") || sLower.includes("hấp thụ")) {
            finalDamage *= 0.8; 
            // Heal logic would go here if we tracked current HP in session, but simpler to just mark effect
            description = `Hấp thụ sinh lực đối thủ!`;
            effectType = 'LIFESTEAL';
            // Apply Heal to self in battle state
            if (isChallenger) battle.p1_hp = Math.min(battle.p1_max_hp, battle.p1_hp + Math.floor(finalDamage * 0.3));
            else battle.p2_hp = Math.min(battle.p2_max_hp, battle.p2_hp + Math.floor(finalDamage * 0.3));
        }
        else if (sLower.includes("raphael") || sLower.includes("thông thái")) {
            finalDamage *= 1.2;
            description = `Tính toán điểm yếu tuyệt đối.`;
            effectType = 'CRIT';
        }
        else if (sLower.includes("hư không") || sLower.includes("void") || sLower.includes("genesis") || sLower.includes("azathoth")) {
            finalDamage = 999999999;
            description = `Hư vô nuốt chửng thực tại. Sát thương chuẩn.`;
            effectType = 'VOID';
        }
        else if (attackerStats.status.isGodMode) {
            finalDamage = 99999999999999999999999999;
            description = `Quyền năng tối thượng của Đấng Sáng Tạo.`;
            effectType = 'VOID';
        }
        else {
            // Generic skill boost
            finalDamage *= 1.1;
            description = `Kích hoạt kỹ năng tấn công.`;
        }

        // Apply Damage
        const damageInt = Math.floor(finalDamage);
        
        let n1hp = BigInt(battle.p1_hp);
        let n2hp = BigInt(battle.p2_hp);
        
        if (isChallenger) n2hp = n2hp - BigInt(damageInt);
        else n1hp = n1hp - BigInt(damageInt);

        const newLog: BattleLogEntry = { 
            turn: (battle.logs.length || 0) + 1, 
            actor: user.username, 
            skill: skillName, 
            damage: damageInt, 
            description: description,
            effect: effectType
        };
        
        const updatedLogs = [...(battle.logs || []), newLog];

        if (n1hp <= 0n || n2hp <= 0n) {
            await this.supabase.from('tensura_battles').update({ logs: updatedLogs, p1_hp: Number(n1hp), p2_hp: Number(n2hp), status: 'FINISHED', winner: n1hp > 0n ? battle.challenger : battle.target }).eq('id', battle.id);
        } else {
            await this.supabase.from('tensura_battles').update({ p1_hp: Number(n1hp), p2_hp: Number(n2hp), logs: updatedLogs, turn: opponentName }).eq('id', battle.id);
        }
    }

    async surrenderBattle(battleId: number, username: string) {
        const { data: battle } = await this.supabase.from('tensura_battles').select('*').eq('id', battleId).single();
        if (!battle) return;
        const winner = battle.challenger === username ? battle.target : battle.challenger;
        await this.supabase.from('tensura_battles').update({ 
            status: 'FINISHED', 
            winner 
        }).eq('id', battleId);
    }

    // --- ADMIN BATTLE MANAGEMENT ---
    async getAdminActiveBattles(): Promise<BattleState[]> {
        const { data } = await this.supabase.from('tensura_battles')
            .select('*')
            .neq('status', 'FINISHED')
            .neq('status', 'DECLINED')
            .order('created_at', { ascending: false });
        return (data as BattleState[]) || [];
    }

    async adminStopBattle(battleId: number) {
        // Force stop as a DRAW or System Intervention
        await this.supabase.from('tensura_battles').update({ 
            status: 'FINISHED', 
            winner: 'SYSTEM_INTERVENTION' 
        }).eq('id', battleId);
    }

    async adminDeleteBattle(battleId: number) {
        await this.supabase.from('tensura_battles').delete().eq('id', battleId);
    }
    // --------------------------------

    async checkPendingInvite(username: string): Promise<BattleState | null> {
        const { data } = await this.supabase.from('tensura_battles').select('*').eq('status', 'PENDING').eq('target', username).single();
        return data as BattleState;
    }

    async checkActiveBattle(username: string): Promise<BattleState | null> {
        const { data } = await this.supabase.from('tensura_battles').select('*').eq('status', 'IN_PROGRESS').or(`challenger.eq.${username},target.eq.${username}`).single();
        return data as BattleState;
    }

    async acceptBattle(id: number) { await this.supabase.from('tensura_battles').update({ status: 'IN_PROGRESS' }).eq('id', id); }
    async declineBattle(id: number) { await this.supabase.from('tensura_battles').update({ status: 'DECLINED' }).eq('id', id); }
    async getBattle(id: number) { const { data } = await this.supabase.from('tensura_battles').select('*').eq('id', id).single(); return data as BattleState; }

    subscribeToChanges(cb: Function) {
        const channel = this.supabase.channel('players_changes')
            .on('postgres_changes', { event: '*', schema: 'public', table: 'tensura_players' }, () => cb())
            .subscribe();
        return () => this.supabase.removeChannel(channel);
    }
}

export const authService = new AuthService();
